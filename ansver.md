<style>    
    code {
        background-color: #f0f0f0;
        font-family: Consolas, Monaco, 'Courier New', Courier, monospace;
        color:rgb(0, 27, 204) !important;
    }
</style>


# 1 - Указатель на void. стандартные функции обработки областей памяти

Для чего используется указатель на void, примеры. особенности использования + примеры. Про функции обработки областей памяти memcpy, memset, memmove

## Для чего используется указатель на void, примеры.

Тип указатель void (обобщенный указатель, англ.
generic pointer) используется, если тип объекта
неизвестен:

- полезен для ссылки на произвольный участок
памяти, независимо от размещенных там
объектов;

```c
void *a;
int num = 52;
a = &num;
printf("%d", *(int*)a);
```

- позволяет передавать в функцию указатель на
объект любого типа.

```c
void print(void *ptr, char type) 
{
    if (type == 'i') 
        printf("%d\n", *(int*)ptr);
    if (type == 'f') 
        printf("%.2f\n", *(float*)ptr);
}
```

## особенности использования + примеры

**Указатель типа void нельзя разыменовывать.**

```c
void *a;
int num = 52;
a = &num;
printf("%d", *a); // ПИСЮН - логично так как не понятно к какому типу мы приведём переменную
```

**К указателям типа void не применима адресная арифметика**

```c
void *a;  
int vodstok_data[6] = {1969, 1979, 1989, 1994, 1999, 2009};
a = vodstok_data; 
a++; // ПИСЮН - логично так как не понятно на сколько ячеек памяти мы должны двинуться (size же разный)
```

## memcpy

`memcpy` копирует данные побайтово

**Сигнатура**

```c
void *memcpy(void *dest, const void *src, size_t count);
```

- dest — указатель на область памяти, куда будут скопированы данные.
- src — указатель на область памяти, откуда будут скопированы данные.
- n — количество байт для копирования.

Если области памяти `src` и `dest` перекрываются, поведение memcpy не определено

**Пример**

```c
int src[5] = {1, 2, 3, 4, 5};
int dest[5];

// Копируем 5 элементов (по размеру int) из src в dest
memcpy(dest, src, 5 * sizeof(int));
```

## memset

'memset' заполняет блок памяти указанным значением.

**Сигнатура**

```c
int memcmp(const void *s1, const void *s2, size_t n);  
```

- s1 и s2 — указатели на блоки памяти для сравнения.    
- n — количество байт для сравнения.  

Полезен для работы с сырыми данными.    

## memmove


**Сигнатура**

```c
void *memmove(void *destptr, const void * srcptr, size_t num);
```

Переместить блок памяти. Функция копирует num байтов из блока памяти источника, на который ссылается указатель `srcptr`, в блок памяти назначения, на который указывает указатель `destptr`. Копирование происходит через промежуточный буфер, что, в свою очередь, не позволяет destination и `srcptr` пересекаться.


**Пример**

```c
int src[5] = {1, 2, 3, 4, 5};
int dest[5];

// Копируем 5 элементов (по размеру int) из src в dest
memmove(dest, src, 5 * sizeof(int));
```

# 2 - Функции динамического выделения памяти

Про malloc, calloc, free. Порядок работы с функциями, особенности их работы. realloc и основные ошибки с ней. Явное приведение типа (за и против). Вопрос выделения 0 байт памяти ++ общие свойства, присущие функциям calloc, malloc, realloc.

## Особенности malloc, calloc, realloc

Библиотека `#include <stdlib.h>`

- Указанные функции не создают переменную, они
лишь выделяют область памяти. В качестве
результата функции возвращают адрес
расположения этой области в памяти компьютера,
т.е. указатель.

- Поскольку ни одна из этих функций не знает
данные какого типа будут располагаться в
выделенном блоке все они возвращают указатель
на void.

- В случае если запрашиваемый блок памяти
выделить не удалось, любая из этих функций
вернет значение NULL.

- После использования блока памяти он должен
быть освобожден. Сделать это можно с помощью
функции free.

## malloc

**Сигнатура**

```c
void* malloc(size_t size);
```

- Функция malloc (C99 7.20.3.3) выделяет блок
памяти указанного размера size. Величина size
указывается в байтах. 

- Выделенный блок памяти не инициализируется
(т.е. содержит «мусор»).

---
**Пример**

```c
void *a = malloc(sizeof(int) * 3);

```
---
**malloc и явное приведение типа**

```c
a = (int*) malloc(n * sizeof(int));
```

*Преимущества явного приведения типа:*
- компиляции с помощью c++ компилятора;

- у функции `malloc` до стандарта `ANSI C` был другой прототип `(char* malloc(size_t size))`

- дополнительная «проверка» аргументов разработчиком.

*Недостатки явного приведения типа:*
- начиная с `ANSI C` приведение не нужно

- может скрыть ошибку, если забыли подключить `stdlib.h`

- в случае изменения типа указателя придется менять и тип в приведении.

---

Короче щас это не нужно это нужно было только до стандарта `ANSI C` из за другой сигнатуры функции `malloc`

Нужно только если мы хотим делать какие либо шуры муры с c++

## calloc

**Сигнатура**

```c
void* calloc(size_t nmemb, size_t size);
```

- Функция calloc (C99 7.20.3.1) выделяет блок
памяти для массива из nmemb элементов, каждый
из которых имеет размер size байт.

- Выделенная область памяти инициализируется
таким образом, чтобы каждый бит имел значение 0. 
(и дальше уже будет преборазование в зависимости от типа то есть если мы будет массив char он будет заполнен пустыми символами возмножно хуйню несу) 



---
**Пример**

```c
a = calloc(n, sizeof(int));
```
---

## realloc

Перевыделение памяти

```c
void* realloc(void *ptr, size_t size); 
```

- `ptr == NULL && size != 0` Выделение памяти (как malloc)
- `ptr != NULL && size == 0` Освобождение памяти (как free).
- `ptr != NULL && size != 0` Перевыделение памяти

Перевыделение памяти (в худшем случае)

- выделить новую область
- скопировать данные из старой области в новую
- освободить старую область

возвращает указатель на новую ячейку памяти

если выделение не удалось возвращает `NULL`

При использовании обязательно нужно сделать вспомогательный указатель 
в который передать возвращаемое значение realloc
и в случае если значение не `NULL` присвоить указатель

```c
void *ptmp = realloc(pbuf, 2 * n);
if (ptmp)
    pbuf = ptmp;
else
    // обработка ошибочной ситуации
```

## Что будет, если запросить 0 байт?

зависит от реализации (implementation-defined C99 7.20.3)

- вернется нулевой указатель;
- вернется «нормальный» указатель, но его нельзя использоваться для разыменования.

Короче или `NULL` или норм указатель но с которым нихуя нельзя сделать

## free

```c
void free(void *ptr);
```
Функция free (C99 7.20.3.2) освобождает (делает возможным повторное использование) ранее выделенный блок памяти, на который указывает ptr. 
- Если значением ptr является нулевой указатель, ничего не происходит.  
- Если указатель ptr указывает на блок памяти, который не был получен с помощью одной из функций malloc, calloc или realloc, поведение функции free не определено. 
- Если попытаться освободить дважды указатель выделенные одной из функций выделения памяти, то `UB`


# 3 - Выделение памяти под динамический массив. Типичные ошибки при работе динамической памяти.


2 способа возврата динамического массива из функции. Реализовать функции. 

О типичных ошибках при работе с динамической памятью.

Подходы к обработке ситуации когда ф-ции дин. памяти вернули null.

## 2 способа возврата динамического массива из функции. Реализовать функции.

- Как возвращаемое значение
```c
int* create_array(FILE *f, size_t *n);
```
- Как параметр функции
```c
int create_array(FILE *f, int **arr, size_t *n);
```

## О типичных ошибках при работе с динамической памятью. 

- Неверный расчет количества выделяемой памяти.
- Отсутствие проверки успешности выделения памяти
- Утечки памяти
- Логические ошибки

**Логические ошибки**
- Wild (англ., дикий) pointer: использование непроинициализированного указателя.
- Dangling (англ., висящий) pointer: использование указателя сразу после освобождения памяти.
- Изменение указателя, который вернула функция выделения памяти. - Двойное освобождение памяти.
- Освобождение невыделенной или нединамической памяти.
- Выход за границы динамического массива. 

## Подходы к обработке ситуации когда ф-ции дин. памяти вернули null.

- Возвращение ошибки (англ., return failure) – Подход, который используем мы 
- Ошибка сегментации (англ., segfault) – Обратная сторона - проблемы с безопасностью 
- Аварийное завершение (англ., abort) – Идея принадлежит Кернигану и Ритчи 
(xmalloc) 
- Восстановление (англ., recovery) – xmalloc из git 

# 4 - Указатели на функции. Функция qsort

Для чего в Си используются указатели на функции + примеры.

Как описывается, инициализируется указатель на функцию. 

Как с его помощью  вызывается сама функция. 

Про qsort, примеры использования. 

Особенности использования указ. на функцию (про адресную арифметику). 

Про указатели на функцию и указатели на void

## Для чего в Си используются указатели на функции + примеры.

- функции обратного вызова (англ., callback);
- таблицы переходов (англ., jump table);
- динамическое связывание (англ., binding).

Callback (англ, функция обратного вызова) -
передача исполняемого кода в качестве одного из
параметров другого кода. 

**Пример**

`qsort`

---
Jump table (или таблица переходов) — это структура данных, которая используется для быстрого перехода между различными точками в программе.

**Пример**
```c
void func1() {
    printf("Function 1\n");
}

void func2() {
    printf("Function 2\n");
}

int main() {
    void (*jumpTable[3])() = {func1, func2};  // Jump table

    int choice;
    printf("Enter a number (0-1): ");
    scanf("%d", &choice);

    if (choice >= 0 && choice < 2) {
        jumpTable[choice]();  // Вызов функции по индексу
    } else {
        printf("Invalid choice\n");
    }

    return 0;
}
```

---

**Прочекать исправить**

Binding в программировании — это процесс связывания имен (или переменных) с объектами, функциями или значениями



---


## Как описывается, инициализируется указатель на функцию. 

**Общее описание**

```c
return_type (*pointer_name)(parameter_types);
```

**Инициализация**

```c
int add(int a, int b) {
    return a + b;
}

int (*func_ptr)(int, int) = add; // Инициализация указателя адресом функции
```

## Как с его помощью  вызывается сама функция. 

Как та же функция только с другим именем

## Про qsort, примеры использования.

```c
void qsort(void *base, size_t nmemb, size_t size, int (*comparator)(const void*, const void*));
```

Для функции `qsort` небоходимо разработать свой comparator (очевидно который соответствует сигнатруре приведённой в функции)

`qsort` может обрабатывать любой тип данных так как мы передаём размер одной ячейки нашего массива и функцию для сравнения этих числе

comparator ОБЯЗАТЕЛЬНО ДОЛЖЕН ВОЗВРАЩАТЬ
- ЧИСЛО 0 ПРИ РАВЕНСТВЕ ЧИСЛО 
- БОЛЬШЕ 0 ЕСЛИ ПЕРВОЕ ЗНАЧЕНИЕ БОЛЬШЕ (НУ ИЛИ МЕНЬШЕ ЕСЛИ ВЫ ХОТИТЕ СОРТИРОВАТЬ ПО УБЫВАНИЯ) 
- МЕНЬШЕ НУЛЯ ЕСЛИ ПЕРВОЕ МЕНЬШЕ (НУ ИЛИ БОЛЬШЕ ЕСЛИ ВЫ ХОТИТЕ СОРТИРОВАТЬ ПО УБЫВАНИЯ) 


## Особенности использования указ. на функцию (про адресную арифметику). 

Операция "&" для функции возвращает указатель на
функцию, но из-за 6.7.5.3 #8 это лишняя операция.


```c
int (*p2)(int, int) = &add;
```

<sup>Короче это нахуй не нужно очередная устаревшая параша</sup>

---
Операция "*" для указателя на функцию возвращает
саму функцию, которая неявно преобразуется в
указатель на функцию.

```c
int (*p3)(int, int) = *add;
int (*p4)(int, int) = *****add;
```

<sup>Даже не устаревшая а просто параша нахуй не нужна отпиздите меня санными тряпками если я не прав</sup>

---

Указатель на функцию может быть типом
возвращаемого значения функции

```c
#include <stdio.h>

// Функции
int add(int a, int b) { return a + b; }
int multiply(int a, int b) { return a * b; }

// Функция, возвращающая указатель на функцию
//  то что передалось в самау изнчальную функцию и её название 
//                     |          
// то соответтсвует   |  сигнатуре возращаемой функции
// |                  |          |    |
// v                 v          v    v
int (*get_operation(char op))(int, int) {
    return (op == '+') ? add : multiply;
}

int main() {
    // Получаем указатель на функцию add
    int (*operation)(int, int) = get_operation('+');
    
    // Вызов функции через указатель
    printf("%d\n", operation(3, 4)); // Вывод: 7

    // Получаем указатель на функцию multiply
    operation = get_operation('*');
    
    // Вызов функции через указатель
    printf("%d\n", operation(3, 4)); // Вывод: 12

    return 0;
}
```

## Про указатели на функцию и указатели на void

Функция - не объект в терминологии стандарта.

Указатель на функцию одного типа может быть преобразован в
указатель на функцию другого типа и обратно;
результат должен быть равен исходному указателю. Если
преобразованный указатель используется для вызова функции, тип
которой несовместим с указанным типом, поведение
не определено.

Согласно C99 6.3.2.3 #1 и C99 6.3.2.3 #8, указатель
на функцию не может быть преобразован к
указателю на void и наоборот.

Но POSIX требует, чтобы такое преобразование
было возможно при работе с динамическими
библиотеками.

# 5 - Утилита make. Назначение, простой сценарий сборки

#### Утилита make
Автоматизирует процесс преобразования файлов из одной формы в другую.  
Разновидности:
- GNU Make (наша радость)
- BSD Make
- Microsoft Make

Для утилиты `make` входным данным является `makefile` - текстовый файл определенного формата, описывающий
- отношения между файлами программы
- команды для обновления каждого файла

Также `make` использует время последнего изменения файла чтобы решить, какие файлы надо обновить

#### Простой сценарий сборки:
```makefile
app.exe: main.o list.o 
    gcc -std=c99 -Wall -Werror -Wpedantic -Wextra -o app.exe main.o list.o

main.o: main.c 
    gcc -std=c99 -Wall -Werror -Wpedantic -Wextra -c main.c

list.o: list.c list.h
    gcc -std=c99 -Wall -Werror -Wpedantic -Wextra -c main.c

clean:
    rm *.o *.exe
```
Как работает данный `makefile`:  
Пока что в программе находятся только исходники. По запуску утилиты
```bash
make
```
она по умолчанию выполняет первую цель (`app.exe`). Видит зависимости, которые должны присутствовать в проекте, но их пока что нет, поэтому идет по очереди их выполнять.  
Для зависимости `main.o` есть все необходимое (`main.c`), поэтому сначала выполнится команда цели `main.o`.  
После этого выполнится `list.o`, затем `app.exe`.

Допустим, мы поменяли файл `list.c` и собираем программу. Программа make проверит, что цели содержат актуальные файлы. Для цели `main.o` все так, для `list.o` нет, так как `list.c` был изменен позже, чем имеющийся `list.o` -> он не актуальный и нужно его обновить. После обновления все объектники актуальные и тогда соберется `app.exe`.

#### Ключи утилиты
Указание конкретного мейкфайла
```makefile
make -f makefile_2
```
Безусловное выполнение правил
```makefile
make -B
```
Вывод команд без их выполнения
```makefile
make -n
```
Игнорирование ошибок при выполнении команд
```makefile
make -i
```

# 6 - Утилита make. Назначение, переменные, шаблонные правила
Для чего make, какие у нее входные данные, какая идея лежит в основе ее работы ++ какие разновидности утилиты make существуют. О переменных (бывают обычные, неявные, автоматические переменные - рассказать о каждой, для чего нужна и как использовать). Про шаблонные правила
# 7 - Утилита make. Назначение, условные конструкции, анализ зависимостей
Для чего make, какие у нее входные данные, какая идея лежит в основе ее работы ++ какие разновидности утилиты make существуют. 2 подхода к реализации условных конструкций: директивы условные и переменные, которые зависят от целей. Рассмотреть анализ зависимостей в утилите make, 3 подхода (ручной анализ, подход когда любой си файл зависит от всех заголовочных файлов, автоматическая генерация зависимостей)
# 8 - Динамические матрицы. 
## Представление в виде одномерного массива и в виде массива указателей на строки. Анализ преимуществ и недостатков
Рассказать про 2 представления, сравнить между собой. Как динамическая матрица в том или ином представлении представлена в памяти компьютера + схема. Алгоритм выделения, освобождения памяти для матрицы. После анализ 2 представления с точки зрения + и - (таблица).

Почему-то с 8 по 13 вопросы одно и то же...

# 14 - Чтение сложных объявлений
О правилах чтения сложных объявлений в Си. Есть словарь, правила. Примеры чтения данных объявлений. Остановиться на ситуациях, которые в процессе чтения возникнуть не должны
# 15 - Строки в динамической памяти, функции POSIX, расширение GNU
3 функции, которые относятся к POSIX и GNU: strdup, getline, sprintf. Нужно не только рассказать про функции и особенности их работы, но и реализовать их функционал самостоятельно (подготовить getline). Про Feature Test Macro: что это такое, для чего нужно.
# 16 - Особенности использования структур с полями-указателями
Нужны примеры. Фраза о том, что операция присваивание в Си для структурных переменных по сути выполняет побитовое переменное 1 структурной переменной в область другой -> выводы о том, к чему приводит такое копирование в случае, если одно из полей - указатель. Рассказать о поверхностном и глубоком копировании. Про рекурсивное освобождение памяти из под структурных переменных (память под структуру динамическая и внутри нее есть динамические поля) ++Поверхностное - не всегда плохо
# 17 - Структуры переменного размера
Про поле типа flexible array member (появился в Си 99, но до этого тоже что-то было, КАК): все его особенности. Пример работы с подобной структурой (пример есть в лекции). Сравнить поле flexible array member с обычным указателем: + и -.
# 18 - Динамически расширяемый массив
Определение массива. Чем динамический массив отличается от динамически расширяемого. Описание типа, функции добавления и удаления. Особенности использования. ++Почему при перевыделении памяти эту память следует перевыделять крупными блоками.
# 19 - Линейный односвязный список. Добавление удаление элемента
Определение узла, списка, линейного односвязного списка. Чем отличаются массивы от списков. Реализовать функции и сопроводить ее схемой-картинкой. Как описывается и освобождается эта структура в Си.
# 20 - Линейный односвязный список. Вставка, удаление элемента
Определение узла, списка, линейного односвязного списка. Чем отличаются массивы от списков. Реализовать функции и сопроводить ее схемой-картинкой. Как описывается и освобождается эта структура в Си.
# 21 - Линейный односвязный список. Обход
Определение узла, списка, линейного односвязного списка. Чем отличаются массивы от списков. Реализовать функции и сопроводить ее схемой-картинкой. Как описывается и освобождается эта структура в Си.
# 22 - Бинарное дерево поиска. Добавление элемента
Что такое дерево. Чем бинарное дерево поиска отличается от обычного. Особенности бинарного дерева поиска. ++ Про узлы. Как описывается и освобождается эта структура в Си.
# 23 - Бинарное дерево поиска. Поиск элемента
Что такое дерево. Чем бинарное дерево поиска отличается от обычного. Особенности бинарного дерева поиска. ++ Про узлы. Поиск элемента в 2 версиях: рекурсивный и нерекурсивный. Привести оба варианта. Как описывается и освобождается эта структура в Си.
# 24 - Бинарное дерево поиска. Обход
Что такое дерево. Чем бинарное дерево поиска отличается от обычного. Особенности бинарного дерева поиска. ++ Про узлы. 3 вида обхода: для решения каких задач какой вид используется. Как описывается и освобождается эта структура в Си.
# 25 - Бинарное дерево поиска. Удаление элемента
Что такое дерево. Чем бинарное дерево поиска отличается от обычного. Особенности бинарного дерева поиска. ++ Про узлы. Как описывается и освобождается эта структура в Си.
# 26 - Куча в программе на Си. Алгоритм работы функций malloc free
//Скорее всего будет разделено на 3 вопроса: 1) malloc, 2) free, 3) выравнивание
Когда описывается алгоритм работы malloc или free нужно не только словесное описание но и сама реализация соответствующей функции (как на лекции). Лучше сразу реализацию и потом как комментарии писать общий алгоритм.
# 27 - Variable length array. Функция alloca
Рассказать про оба(FLA|VLA ?) и таблица сравнения VLA vs alloca.
# 28 - Функции с переменным числом параметров
Изложить идею, которая лежит в основе реализации функции с переменным числом параметров, потом сказать что так делать нельзя. Рассказать как правильно реализовывать функции с переменным числом параметров с помощью стандартной библиотеки.
# 29 - Препроцессор. Общие понятия. Директивы include, простые макросы, предопределенные макросы.

# 30 - Препроцессор. Макросы с параметрами

# 31 - Препроцессор. Общие поняти, директивы условной компиляции, директивы error и pragma
Указать проблему использования директивы if и ifdef. //Не было обсуждено на лекции, но в примерах лежит файл, на основе которого нужно сделать выводы самому (?)
# 32 - Препроцессор. Общие понятия, операция # и ##

# 33 - Встраиваемые функции.
Почему в Си появилось ключевое слово inline. Какие особенности есть у встраиваемых функций с точки зрения стандарта к чему они приводят. Как бороться с проблемой unresolved symbol при использовании inline (было рассмотрено 3-4 подхода).
# 34 - Библиотеки. Статические библиотеки.
// Текст далее относится в целом про библиотеки:
Особенности работы компоновщика, проблема видимости функций, что такое position independent code и как он устроен в Linux в ELF, LD_LIBRARY_PATH и R PATH (2 подхода), LD_PRELOAD и все что было на лекции. 

// Может быть отдельным вопросом (если нет, то тоже указываем):
Про 2 подхода к функциям, которые выделяют динамическую память: либо выделяем в библиотеке и пишем там функцию для очистки, либо все вопросы с выделением и освобождением памяти перекладываем на вызывающую сторону.

# 35 - Библиотеки. Динамические библиотеки. Динамическая компоновка.

# 36 - Библиотеки. Динамические библиотеки. Динамическая загрузка.

# 37 - Библиотеки. Динамические библиотеки на Си, приложение на Питоне
## 37.1 - ctypes
Про ctypes подробно. Как модулем ctypes пользоваться на примерах функции целочисленного сложения и целочисленного деления.
## 37.2 - ctypes
Про ctypes немного. Как с его помощью реализовать функции, которые работают с массивами.
## 37.3 - функции модули расширения. Разработка модуля расширения
Какие шаги нужно выполнить, чтобы реализовать модуль расширения. Подключить Python.h, все функции имеют один и тот же заголовок, как из аргументов, переданных императором, достать переменные в Си, как потом сформировать результат, что есть за метаинформация и т.д.
## 37.4 - все из 37.1-37.3 + разработка функции модуля расширени, которая обрабатывает последовательность.

# 38 - Абстрактный тип данных. Понятие модуль. Разновидности модулей. Абстрактный объект стек. 
Определение модуля. Какие разновидности модулей бывают. Какие есть средства для реализации модулей в Си. Далее про абстрактный объект с примером реализации. // Если не успеваете, то начинаете с примера: реализация, а потом уже туда докинуть что-то из теории.
# 39 - Абстрактный тип данных. Понятие модуль. Разновидности модулей. Абстрактный тип данных стек целых чисел
Определение модуля. Какие разновидности модулей бывают. Какие есть средства для реализации модулей в Си. Далее про абстрактный тип данных с примером реализации. // Если не успеваете, то начинаете с примера: реализация, а потом уже туда докинуть что-то из теории.
# 40 - Списки ядра Линкус (горите в 9 кругах ада). Идеи, основные моменты использования.
Реализовать приложение по примеру того, что было в лекции (простейший список целых чисел с добавлением элемента, обходом списка, удалением элемента и освобождением памяти).
// Должна быть предоставлена шпаргалка с названиями макросов. Если ее нет, напомнить

# 41 - Списки ядра Линкус. Идея, основные моменты реализации.
Сосредоточиться на реализации макроса container_of. (как по указателю на поле структуры можно получить указатель на саму структуру).
// Должна быть предоставлена шпаргалка с названиями макросов. Если ее нет, напомнить

Надеюсь, конец :) 
